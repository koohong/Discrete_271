for(pi in pi.seq) {
pmf <- dbinom(x = w, size = n, prob = pi)
# Wald
save.wald <- pi>lower.wald & pi<upper.wald  # Check if pi is within interval
# Could use ifelse() too:
# save.wald <- ifelse(test = pi>lower.wald, yes = ifelse(test = pi<upper.wald, yes = 1, no = 0), no = 0)
wald <- sum(save.wald*pmf)
# Agresti-Coull
save.AC <- pi>lower.AC & pi<upper.AC
# ifelse(test = pi>lower.AC, yes = ifelse(test = pi<upper.AC, yes = 1, no = 0), no = 0)
AC <- sum(save.AC*pmf)
# Wilson
save.wilson <- pi>lower.wilson & pi<upper.wilson
# save.wilson <- ifelse(test = pi>lower.wilson, yes = ifelse(test = pi<upper.wilson, yes = 1, no = 0), no = 0)
wilson <- sum(save.wilson*pmf)
# Clopper-Pearson
save.CP <- pi>lower.CP & pi<upper.CP
# save.CP <- ifelse(test = pi>lower.CP, yes = ifelse(test = pi<upper.CP, yes = 1, no = 0), no = 0)
CP <- sum(save.CP*pmf)
save.true.conf[counter,] <- c(pi, wald, AC, wilson, CP)
counter <- counter+1
}
# Plots
# dev.new(width = 7, height = 6, pointsize = 12)
# pdf(file = "c:\\figures\\Figure1.3.pdf", width = 7, height = 6, colormodel = "cmyk")   # Create plot for book
par(mfrow = c(2,2))  # 2x2 plotting grid
plot(x = save.true.conf[,1], y = save.true.conf[,2], main = "Wald", xlab = expression(pi),
ylab = "True confidence level", type = "l", ylim = c(0.85,1))
abline(h = 1-alpha, lty = "dotted")
segments(x0 = 0.157, y0 = 0, x1 = 0.157,
y1 = save.true.conf[save.true.conf[,1]==0.157,2], lty = "dotdash")
segments(x0 = -1, y0 = save.true.conf[save.true.conf[,1]==0.157,2], x1 = 0.157,
y1 = save.true.conf[save.true.conf[,1]==0.157,2], lty = "dotdash")
plot(x = save.true.conf[,1], y = save.true.conf[,3], main = "Agresti-Coull", xlab = expression(pi),
ylab = "True confidence level", type = "l", ylim = c(0.85,1))
abline(h = 1-alpha, lty = "dotted")
plot(x = save.true.conf[,1], y = save.true.conf[,4], main = "Wilson", xlab = expression(pi),
ylab = "True confidence level", type = "l", ylim = c(0.85,1))
abline(h = 1-alpha, lty = "dotted")
plot(x = save.true.conf[,1], y = save.true.conf[,5], main = "Clopper-Pearson", xlab = expression(pi),
ylab = "True confidence level", type = "l", ylim = c(0.85,1))
abline(h = 1-alpha, lty = "dotted")
# dev.off()  # Create plot for book
# Pi = 0.157
# save.true.conf[save.true.conf[,1]==0.157, ]
# While AC and Wilson have same true confidence levels at pi=0.157, this will not always be the case
# sum(save.true.conf[,3] != save.true.conf[,4])  # Number of differences
# length(pi.seq)  # Number of true confidence levels
# Chunk 5
#| echo: true
c.table <- array(data = c(251, 48, 34, 5), dim = c(2,2),
dimnames = list(First = c("made", "missed"), Second = c("made", "missed")))
c.table
#conditional probabilities
pi.hat.table <- c.table/rowSums(c.table)
#get the pi estimates
pi.hat1 <- pi.hat.table[1,1]
pi.hat2 <- pi.hat.table[2,1]
#set type I error
alpha <- 0.05
# Chunk 6
#########################
#wald CI
#########################
var.wald <- pi.hat1*(1-pi.hat1) / sum(c.table[1,]) +
pi.hat2*(1-pi.hat2) / sum(c.table[2,])
pi.hat1 - pi.hat2 + qnorm(p = c(alpha/2, 1-alpha /2)) *
sqrt(var.wald)
# Chunk 7
#########################
# Agresti-Caffo
#########################
pi.tilde1 <- (c.table[1,1] + 1) / (sum(c.table[1,]) + 2)
pi.tilde2 <- (c.table[2,1] + 1) / (sum(c.table[2,]) + 2)
var.AC <- pi.tilde1*(1-pi.tilde1) / (sum(c.table[1,]) + 2) +
pi.tilde2*(1-pi.tilde2) / (sum(c.table[2,]) + 2)
pi.tilde1 - pi.tilde2 + qnorm(p = c(alpha/2, 1-alpha /2)) *sqrt(var.AC)
# Chunk 8
#| echo: true
prop.test(x = c.table , conf.level = 0.95, correct = FALSE)
# Chunk 9
#| echo: true
c.table <- array(data = c(57, 142, 200688, 201087), dim =
c(2,2), dimnames = list(Treatment = c("vaccine", "placebo"), Result = c("polio", "polio free")))
c.table
#calculate conditional probability
pi.hat.table <- c.table/rowSums(c.table)
pi.hat.table
#estimated parameters to be compared
pi.hat1 <- pi.hat.table[1,1]
pi.hat2 <- pi.hat.table[2,1]
RR <- pi.hat1/pi.hat2
RR
# Chunk 10
#| echo: true
#set type 1 error
alpha <- 0.05
n1 <- sum(c.table[1,])
n2 <- sum(c.table[2,])
var.log.rr <- (1-pi.hat1)/(n1*pi.hat1) + (1-pi.hat2)/(n2*pi.hat2)
ci <- exp(log(pi.hat1/pi.hat2) + qnorm(p = c(alpha/2,
1-alpha/2)) * sqrt(var.log.rr))
ci
# Chunk 11
# library(here)
# library(readxl)
df <- read_excel(here("def.xlsx"), sheet = "or")
# Chunk 12: tbl-penguins-top10
#| label: tbl-penguins-top10
#| tbl-cap: First 10 Penguins
#replacing NA with white space
df[is.na(df)] <- ""
df %>% kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Chunk 13
OR.hat <- c.table[1,1] * c.table[2,2] / (c.table[2,1] *
c.table[1,2])
round(OR.hat , 4)
#get confidence interval
alpha <- 0.05
var.log.or <- 1/c.table[1,1] + 1/c.table[1,2] + 1/c.table[2,1]
+ 1/c.table[2,2]
OR.CI <- exp(log(OR.hat) + qnorm(p = c(alpha/2, 1-alpha /2)) *
sqrt(var.log.or))
round(OR.CI , 2)
# Chunk 14
#| echo: true
#get marginal distribution
n <- sum(c.table)
pi.hat.plus1 <- sum(c.table[,1])/n
pi.hat.1plus <- sum(c.table[1,])/n
#evaluate the difference by
#subtracting the sample statistics
data.frame(pi.hat.plus1 , pi.hat.1plus ,
diff = pi.hat.plus1 - pi.hat.1plus)
# Chunk 15
#| echo: true
c.table <- array(data = c(4, 3, 6, 3), dim = c(2,2), dimnames =
list(MRI = c("Localized", "Advanced"), Ultrasound =
c("Localized", "Advanced")))
c.table
mcnemar.test(x = c.table , correct = FALSE)
##library(PropCIs)
## wald confidence interval
diffpropci.Wald.mp(b = c.table[1,2], c = c.table[2,1], n =
sum(c.table), conf.level = 0.95)
diffpropci.mp(b = c.table[1,2], c = c.table[2,1], n =
sum(c.table), conf.level = 0.95)
diffpropci.mp(b = c.table[1,2], c = c.table[2,1], n =
sum(c.table), conf.level = 0.95)
diffpropci.mp(b = c.table[1,2], c = c.table[2,2], n =
sum(c.table), conf.level = 0.95)
diffpropci.mp(b = c.table[1,2], c = c.table[2,1], n =
sum(c.table), conf.level = 0.95)
diffpropci.mp(b = c.table[1,1], c = c.table[2,1], n =
sum(c.table), conf.level = 0.95)
diffpropci.mp(b = c.table[1,2], c = c.table[2,1], n =
sum(c.table), conf.level = 0.95)
c.table
library(here)
source(here("source","get_lib.R"))
placekick <- read.table(here("data","Placekick.csv"),header = True, sep = ",")
placekick <- read.table(here("data","Placekick.csv"),header = T, sep = ",")
placekick
placekick %>% head %>% kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
placekick %>% head %>% kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
#fit the model
mod.fit <- glm(formula = good ~ distance , family =
binomial(link = logit), data = placekick)
mod.fit
latex_equation <- extract_eq(mod.fit)
print(latex_equation)
#fit the model
mod.fit <- glm(formula = good ~ distance , family =
binomial(link = logit), data = placekick)
latex_equation <- extract_eq(mod.fit)
print(latex_equation)
mod.fit
tidy(mod.fit)
confint(mod.fit)
summary(mod.fit)
# Chunk 1
library(here)
source(here("source","get_lib.R"))
# Chunk 2
#| echo: true
#get data
placekick <- read.table(here("data","Placekick.csv"),header = T, sep = ",")
placekick %>% head %>% kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
#fit the model
mod.fit <- glm(formula = good ~ distance , family = binomial(link = logit), data = placekick)
mod.fit
# latex_equation <- extract_eq(mod.fit)
# print(latex_equation)
# Chunk 3
#| echo: true
confint(mod.fit)
# Chunk 4
summary(mod.fit)
# Chunk 5
#| echo: true
mod.fit2 <- glm(formula = good ~ change + distance , family =
binomial(link = logit), data = placekick)
#one at a time test
Anova(mod.fit2, test = "LR")
anova(mod.fit, mod.fit2, test = "LR")
# Chunk 6
#| echo: true
#finds LR confidence interval
mod.fit
beta.ci <- confint(mod.fit, parm = "distance", level = 0.95)
beta.ci
# Chunk 7
rev(exp(-10*beta.ci))
# Chunk 8
beta.ci <- confint.default(object = mod.fit , parm = "distance",
level = 0.95)
rev(1/exp(beta.ci*10))
# Chunk 9
linear.pred <- mod.fit$coefficients[1] +
mod.fit$coefficients[2] * 20
#value of the logit function based on given value of distance at 20
linear.pred
new_data <- data.frame(distance = 20)
predict(mod.fit, newdata = new_data, type = "link")
predict(mod.fit, newdata = new_data, type = "response")
# Chunk 10
predict(mod.fit, newdata = new_data, type = "response", se = TRUE)
# Chunk 11
#create a function to get the confidence interval of pi
ci.pi <- function(newdata , mod.fit.obj , alpha){
linear.pred <- predict(object = mod.fit.obj ,
newdata =newdata ,
type = "link", se = TRUE)
CI.lin.pred.lower <- linear.pred$fit - qnorm(p =1-alpha/2)*linear.pred$se
CI.lin.pred.upper <- linear.pred$fit + qnorm(p =1-alpha/2)*linear.pred$se
#get pi
CI.pi.lower <- exp(CI.lin.pred.lower) / (1 +exp(CI.lin.pred.lower))
CI.pi.upper <- exp(CI.lin.pred.upper) / (1 +exp(CI.lin.pred.upper))
list(lower = CI.pi.lower , upper = CI.pi.upper)
}
# Chunk 12
ci.pi(newdata = data.frame(distance = 20), mod.fit.obj = mod.fit , alpha = 0.05)
ci.pi(newdata = data.frame(distance = 20), mod.fit.obj = mod.fit , alpha = 0.05)
plot(x = w$distance , y = w$good/n$good , xlab = "Distance
(yards)", ylab = "Estimated probability", panel.first = grid(col = "gray", lty = "dotted"))
w <- aggregate(formula = good ~ distance , data = placekick , FUN
= sum)
head(placekick)
w <- aggregate(formula = good ~ distance , data = placekick , FUN
= sum)
#| echo: true
df = glow500 %>%
dplyr::select(fracture, age, priorfrac, premeno, raterisk, smoke, bmi)
# Chunk 1
library(here)
source(here("source","get_lib.R"))
# Chunk 2
#| echo: true
#get data
placekick <- read.table(here("data","Placekick.csv"),header = T, sep = ",")
placekick %>% head %>% kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
#fit the model
mod.fit <- glm(formula = good ~ distance , family = binomial(link = logit), data = placekick)
mod.fit
# latex_equation <- extract_eq(mod.fit)
# print(latex_equation)
# Chunk 3
#| echo: true
confint(mod.fit)
# Chunk 4
summary(mod.fit)
# Chunk 5
#| echo: true
mod.fit2 <- glm(formula = good ~ change + distance , family =
binomial(link = logit), data = placekick)
#one at a time test
Anova(mod.fit2, test = "LR")
anova(mod.fit, mod.fit2, test = "LR")
# Chunk 6
#| echo: true
#finds LR confidence interval
mod.fit
beta.ci <- confint(mod.fit, parm = "distance", level = 0.95)
beta.ci
# Chunk 7
rev(exp(-10*beta.ci))
# Chunk 8
beta.ci <- confint.default(object = mod.fit , parm = "distance",
level = 0.95)
rev(1/exp(beta.ci*10))
# Chunk 9
linear.pred <- mod.fit$coefficients[1] +
mod.fit$coefficients[2] * 20
#value of the logit function based on given value of distance at 20
linear.pred
new_data <- data.frame(distance = 20)
predict(mod.fit, newdata = new_data, type = "link")
predict(mod.fit, newdata = new_data, type = "response")
# Chunk 10
predict(mod.fit, newdata = new_data, type = "response", se = TRUE)
# Chunk 11
#create a function to get the confidence interval of pi
ci.pi <- function(newdata , mod.fit.obj , alpha){
linear.pred <- predict(object = mod.fit.obj ,
newdata =newdata ,
type = "link", se = TRUE)
CI.lin.pred.lower <- linear.pred$fit - qnorm(p =1-alpha/2)*linear.pred$se
CI.lin.pred.upper <- linear.pred$fit + qnorm(p =1-alpha/2)*linear.pred$se
#get pi
CI.pi.lower <- exp(CI.lin.pred.lower) / (1 +exp(CI.lin.pred.lower))
CI.pi.upper <- exp(CI.lin.pred.upper) / (1 +exp(CI.lin.pred.upper))
list(lower = CI.pi.lower , upper = CI.pi.upper)
}
# Chunk 12
ci.pi(newdata = data.frame(distance = 20), mod.fit.obj = mod.fit , alpha = 0.05)
# Chunk 13
plot(x = w$distance , y = w$good/n$good , xlab = "Distance
(yards)", ylab = "Estimated probability", panel.first = grid(col = "gray", lty = "dotted"))
curve(expr = predict(object = mod.fit , newdata =
data.frame(distance = x), type = "response"), col = "red", add = TRUE , xlim = c(18, 66))
curve(expr = ci.pi(newdata = data.frame(distance = x),
mod.fit.obj = mod.fit , alpha = 0.05) $lower , col = "blue", lty = "dotdash", add = TRUE , xlim = c(18, 66))
curve(expr = ci.pi(newdata = data.frame(distance = x),
mod.fit.obj = mod.fit , alpha = 0.05) $upper , col = "blue", lty = "dotdash", add = TRUE , xlim = c(18, 66))
legend(locator (1), legend = c("Logistic regression model", "95%
individual C.I."), lty = c("solid", "dotdash"), col = c("red", "blue"), bty = "n")
df %>% count(fracture) %>%
mutate(prop = round(prop.table(n),2)) %>%
kable(col.names = c('Fracture', 'N', "Proportion"))
df %>% kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
#| echo: true
df = glow500 %>%
dplyr::select(fracture, age, priorfrac, premeno, raterisk, smoke, bmi)
df
#| echo: true
df <- glow500 %>%
dplyr::select(fracture, age, priorfrac, premeno, raterisk, smoke, bmi)
df
df %>% count(fracture) %>%
mutate(prop = round(prop.table(n),2)) %>%
kable(col.names = c('Fracture', 'N', "Proportion"))
df %>% count(fracture) %>%
mutate(prop = round(prop.table(n),2)) %>%
kable(col.names = c('Fracture', 'N', "Proportion")) %>%
kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
df %>% count(fracture) %>%
mutate(prop = round(prop.table(n),2)) %>%
kable(col.names = c('Fracture', 'N', "Proportion"), html ) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
df %>% count(fracture) %>%
mutate(prop = round(prop.table(n),2)) %>%
data.frame(col.names = c('Fracture', 'N', "Proportion")) %>%
kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
?kable
df %>% count(fracture) %>%
mutate(prop = round(prop.table(n),2)) %>%
kable(format = "html",col.names = c('Fracture', 'N', "Proportion")) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
df %>%
ggplot(aes(x= fracture, y = ..prop.., group = 1)) +
geom_bar(fill = 'DarkBlue', color = 'black') +
geom_text(stat='count', aes(label=..count..), vjust=-1) +
xlab("Fracture") +
ylab("Proportion") +
ylim(0,1)
p1 <- df %>%
ggplot(aes(x = age)) +
geom_density(aes(y = ..density..,color = fracture, fill = fracture),alpha=0.2) +
ggtitle("Distribution of Subjects' Age") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
xlab("Yaer") +
ylab("Density")
p2 <-df %>%
ggplot(aes(x = bmi)) +
geom_density(aes(y = ..density.., color = fracture, fill = fracture),alpha=0.2) +
ggtitle("Distribution of Subjects'BMI") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
xlab("Body mass index") +
ylab("Density")
p1/p2
p3 <- df %>%
ggplot(aes(fracture, bmi)) +
geom_boxplot(aes(fill = fracture)) +
coord_flip() +
ggtitle("Subjects' BMI by Fracture in the First Year") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
ylab("Body mass index") +
xlab("Fracture")
p4 <- df %>%
ggplot(aes(fracture, age)) +
geom_boxplot(aes(fill = fracture)) +
coord_flip() +
ggtitle(" Age by Fracture in the First Year") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
ylab("Year") +
xlab("Fracture")
p3/p4
p2 <-df %>%
ggplot(aes(x = bmi)) +
geom_density(aes(y = ..density.., color = fracture, fill = fracture),alpha=0.2) +
ggtitle("Distribution of Subjects'BMI") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
xlab("Body mass index") +
ylab("Density")
p1/p2
p5 <- df %>%
ggplot(aes(x=priorfrac,
y = ..prop..,
group = fracture,
fill = fracture)) +
geom_bar( position = 'dodge') +
geom_text(stat='count',
aes(label=..count..),
vjust=-1,
position = position_dodge(width = 1)) +
xlab("prior fracture") +
ylab("Proportion") +
ylim(0,1) +
labs(fill = "fracture")
p6 <- df %>%
ggplot(aes(x=raterisk,
y = ..prop..,
group = fracture,
fill = fracture)) +
geom_bar( position = 'dodge') +
geom_text(stat='count',
aes(label=..count..),
vjust=-1,
position = position_dodge(width = 1)) +
xlab("Self-reported risk of fracture") +
ylab("Proportion") +
ylim(0,1) +
labs(fill = "fracture")
p7 <- df %>%
ggplot(aes(x= premeno,
y = ..prop..,
group = fracture,
fill = fracture)) +
geom_bar( position = 'dodge') +
geom_text(stat='count',
aes(label=..count..),
vjust=-1,
position = position_dodge(width = 1)) +
xlab("Menopause before age 45") +
ylab("Proportion") +
ylim(0,1) +
labs(fill = "fracture")
p8 <- df %>%
ggplot(aes(x= smoke,
y = ..prop..,
group = fracture,
fill = fracture)) +
geom_bar( position = 'dodge') +
geom_text(stat='count',
aes(label=..count..),
vjust=-1,
position = position_dodge(width = 1)) +
xlab("Former or current smoker") +
ylab("Proportion") +
ylim(0,1) +
labs(fill = "fracture")
(p5|p6)/(p7|p8)
p3 <- df %>%
ggplot(aes(fracture, bmi)) +
geom_boxplot(aes(fill = fracture)) +
coord_flip() +
ggtitle("Subjects' BMI by Fracture in the First Year") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
ylab("Body mass index") +
xlab("Fracture")
p4 <- df %>%
ggplot(aes(fracture, age)) +
geom_boxplot(aes(fill = fracture)) +
coord_flip() +
ggtitle(" Age by Fracture in the First Year") +
theme(plot.title = element_text(lineheight=1, face="bold")) +
ylab("Year") +
xlab("Fracture")
p3/p4
dependent <- "fracture"
explanatory <- c("bmi","age", "priorfrac", "premeno", "raterisk", "smoke")
df %>%
summary_factorlist(dependent, explanatory, add_dependent_label = TRUE) %>%
knitr::kable()
dependent <- "fracture"
explanatory <- c("bmi","age", "priorfrac", "premeno", "raterisk", "smoke")
df %>%
summary_factorlist(dependent, explanatory, add_dependent_label = TRUE) %>%
kable("html") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
mod.logit.1 <- glm(fracture ~  bmi + age, family = binomial(link = logit), data = df)
latex_equation <- extract_eq(mod.logit.1 )
print(latex_equation)
summary(mod.logit.1)
print(latex_equation)
mod.logit.2 <- glm(fracture ~  bmi + age + priorfrac + raterisk, family = binomial(link = logit), data = df)
## Get the equation in Latex
latex_equation <- extract_eq(mod.logit.2 )
print(latex_equation)
levels(df$priorfrac)
levels(df$raterisk)
#set reference levels in factors to make interpretation easier
df$priorfrac<-relevel(df$priorfrac, ref="No")
df$raterisk<-relevel(df$raterisk, ref="Less")
